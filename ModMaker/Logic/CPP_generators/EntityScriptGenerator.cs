using LibModMaker;
using System;
using System.IO;
using System.Drawing;
using Microsoft.VisualBasic;

namespace ModMaker
{

    /// <summary>
    /// Generates C++ code given an FGD and some templates
    /// </summary>
    public class EntityScriptGenerator
    {
        private StreamWriter Header;
        private StreamWriter Body;
        private string ClassName;
        private ForgeGameData.EntityDef Entity;
        private System.Text.StringBuilder InputBodies;

        private System.Text.StringBuilder Precache;

        public void Export(SourceMod Game, ForgeGameData.EntityDef Entity, string Folder)
        {
            string HeaderPath = Path.Combine(Folder, Entity.Name + ".h");
            string BodyPath = Path.Combine(Folder, Entity.Name + ".cpp");

            this.Entity = Entity;

            this.ClassName = "C" + ToCamelCase(Entity.Name);

            using (var Header = new StreamWriter(HeaderPath))
            {
                using (var Body = new StreamWriter(BodyPath))
                {
                    this.Header = Header;
                    this.Body = Body;

                    WriteFileHeaders();
                    WriteProperties();
                    WriteInputs();
                    WriteOutputs();
                    WriteFileFooters();
                }
            }

            Interaction.MsgBox("Exported " + BodyPath, MsgBoxStyle.Information, "Mod Maker");
        }

        string ToCamelCase(string Plain)
        {
            System.Text.StringBuilder Result = new System.Text.StringBuilder(Plain.Length);
            bool NextUpper = true;

            foreach (char C in Plain)
            {
                if (NextUpper)
                {
                    Result.Append(char.ToUpper(C));
                    NextUpper = false;
                }
                else
                {
                    if (char.IsWhiteSpace(C) | C == '_')
                    {
                        NextUpper = true;
                    }
                    else
                    {
                        Result.Append(C);
                    }
                }
            }

            return Result.ToString();
        }

        public static string ToCPP_ID(string Plain)
        {
            return CPlusPlus.ToID(Plain);
        }

        void WriteFileHeaders()
        {
            Header.WriteLine("// Purpose: Header for " + Entity.Name);
            Header.WriteLine("// Boilerplate generated by ModMaker on " + DateTime.Now.ToString());
            Header.WriteLine("/* " + Entity.Comment + "*/");
            Header.WriteLine();

            if( Entity.Outputs.Count > 0 )
            {
                Header.WriteLine("#include \"entityouput.h\"");
                Header.WriteLine();
            }

            Header.WriteLine("class {0} : public CBaseEntity // {1}", ClassName, string.Join(", ", Entity.Bases.ToArray()));
            Header.WriteLine("{");
            Header.WriteLine("public:");
            Header.WriteLine("    DECLARE_CLASS( {0}, CBaseEntity );", ClassName);
            Header.WriteLine();

            Body.WriteLine("// Purpose: Body for " + Entity.Name);
            Body.WriteLine("// Boilerplate generated by ModMaker on " + DateTime.Now.ToString());
            Body.WriteLine("/* " + Entity.Comment + "*/");
            Body.WriteLine();
            Body.WriteLine("#include \"cbase.h\"");
            Body.WriteLine("#include \"{0}.h\"", Entity.Name);
            Body.WriteLine();
            Body.WriteLine("// memdbgon must be the last include file in a .cpp file!!!");
            Body.WriteLine("#include \"tier0/memdbgon.h\"");
            Body.WriteLine();
            Body.WriteLine("BEGIN_DATADESC( {0} )", ClassName);
        }

        void WriteProperties()
        {
            Precache = new System.Text.StringBuilder();

            foreach (ForgeGameData.BaseProperty Prop in Entity.Properties.Values)
            {
                WriteProperty(Prop);
            }

            if (Precache.Length > 0)
            {
                Header.WriteLine();
                Header.WriteLine("    virtual void Precache();");
                Header.WriteLine("    virtual void Spawn();");
                Header.WriteLine();
            }
        }

        enum balh_spawnflags
        {
           Firstvalue =0 ,
           secondValue = 1
         }

        void WriteProperty(ForgeGameData.BaseProperty Prop)
        {
            string StorageVar = "m_";
            string StorageType = null;
            string FieldType = null;

            switch (Prop.DataType)
            {
                case "string":
                case "target_source":
                case "target_destination":
                case "node_dest":
                case "filterclass":
                case "decal":
                case "sprite":
                case "material":
                case "sidelist":
                    StorageType = "string_t";
                    StorageVar += "i";
                    FieldType = "FIELD_STRING";
                    break;
                case "studio":
                    StorageType = "string_t";
                    StorageVar += "i";
                    FieldType = "FIELD_MODELNAME";
                    break;
                case "sound":
                    StorageType = "string_t";
                    StorageVar += "i";
                    FieldType = "FIELD_SOUNDNAME";
                    break;
                case "integer":
                case "color255":
                    StorageType = "int";
                    StorageVar += "i";

                    if (Prop.DataType != "color255")
                    {
                        FieldType = "FIELD_INTEGER";
                    }
                    else
                    {
                        FieldType = "FIELD_COLOR32";
                    }
                    break;
                case "float":
                    StorageType = "float";
                    StorageVar += "fl";
                    FieldType = "FIELD_FLOAT";
                    break;
                case "angle":
                case "vector":
                case "vecline":
                case "axis":
                case "origin":
                    StorageType = "Vector";
                    StorageVar += "vec";
                    FieldType = "FIELD_VECTOR";
                    break;
                case "flags":
                    //skip
                    ForgeGameData.FlagsProperty flags = Prop as ForgeGameData.FlagsProperty;

                    Header.WriteLine("    enum {0}\r\n    {{", ToCPP_ID(Entity.Name + "_spawnflags"));
                    foreach (int bitflag in flags.flags.Keys)
                    {
                        Header.WriteLine("        {0} = {1},", ToCPP_ID(flags.flags[bitflag].Name), bitflag);
                    }
                    Header.WriteLine("    }\r\n");

                    break;
                default:
                    StorageType = "string_t";
                    StorageVar += "i";
                    FieldType = "FIELD_VOID";
                    break;
            }

            if (StorageType != null)
            {
                StorageVar += ToCamelCase(Prop.Name);
                StorageVar = ToCPP_ID(StorageVar);

                if (!string.IsNullOrEmpty(Prop.Notes)) Header.WriteLine("/* {0} */", Prop.Notes);

                Header.WriteLine("    {0} {1};", StorageType.PadRight(8), StorageVar);

                Body.WriteLine("    DEFINE_KEYFIELD( {0}, {1}, \"{2}\" ),", StorageVar, FieldType, Prop.Name);
            }

            switch (Prop.DataType)
            {
                case "studio":
                    Precache.AppendFormat("    PrecacheModel( STRING({0}) );\r\n", StorageVar);
                    break;
                case "decal":
                case "sprite":
                case "material":
                    Precache.AppendFormat("    PrecacheMaterial(  STRING({0}) );\r\n", StorageVar);
                    break;
                case "sound":
                    Precache.AppendFormat("    PrecacheScriptSound( STRING({0}) );\r\n", StorageVar);
                    break;
                case "target_source":
                case "target_destination":
                case "node_dest":
                case "filterclass":
                    //TODO lookup named entity
                    break;
            }
        }

        void WriteInputs()
        {
            InputBodies = new System.Text.StringBuilder();

            if (Entity.Inputs.Count > 0)
            {
                Header.WriteLine("");
                Header.WriteLine("    // input handlers");
            }

            foreach (ForgeGameData.IOConnector Input in Entity.Inputs.Values)
            {
                string FunctionName = ToCPP_ID(Input.Name);

                Header.Write("    void {0}( inputdata_t &inputdata );", FunctionName);

                if (!string.IsNullOrEmpty(Input.Notes))
                {
                    Header.Write(" /* {0} */", Input.Notes);
                }

                Header.WriteLine();

                Body.WriteLine("    DEFINE_INPUTFUNC( FIELD_INPUT, \"{0}\", {1} ),", Input.Name, FunctionName);

                InputBodies.AppendFormat("/* {2} */\r\nvoid {0} :: {1}(inputdata_t & inputdata)\r\n{{\r\n}}\r\n", ClassName,
                    FunctionName, Input.Notes);
            }
        }

        void WriteOutputs()
        {
            if (Entity.Outputs.Count > 0)
            {
                Header.WriteLine("");
                Header.WriteLine("    // outputs");
            }

            foreach (ForgeGameData.IOConnector Out in Entity.Outputs.Values)
            {
                string MemberName = ToCPP_ID("m_" + Out.Name);

                Header.Write("    COutputEvent {0};", MemberName);

                if (!string.IsNullOrEmpty(Out.Notes))
                {
                    Header.Write(" /* {0} */", Out.Notes);
                }

                Header.WriteLine();

                Body.WriteLine("    DEFINE_OUTPUT( {0}, \"{1}\" ),", MemberName, Out.Name);
            }
        }

        void WriteFileFooters()
        {
            Header.WriteLine("");
            Header.WriteLine("    DECLARE_DATADESC();");
            Header.WriteLine("};");

            Body.WriteLine("END_DATADESC()");
            Body.WriteLine();
            Body.WriteLine("LINK_ENTITY_TO_CLASS( {0}, {1} );", Entity.Name, ClassName);

            if (Precache.Length > 0)
            {
                Body.WriteLine();
                Body.WriteLine("void {0} ::Precache()\r\n{{", ClassName);
                Body.Write(Precache.ToString());
                Body.WriteLine("}}\r\nvoid {0} ::Spawn()\r\n{{\r\n    BaseClass::Spawn();\r\n\r\n    Precache();\r\n}}", ClassName);
            }

            if (InputBodies.Length > 0)
            {
                Body.WriteLine();
                Body.WriteLine(InputBodies.ToString());
            }
        }
    }

}